behPart ::= beh [letPart]
letPart ::= 'let' localDefinition+
beh ::= simple-beh | complex-beh
simple-beh ::= simple-beh1 | simple-beh2
simple-beh1 ::= event [intervalTimes] [duringTime]
simple-beh2 ::= proposition [duringTime]
beh-operator ::= 'AND' | 'OR' | 'SEQ'
logic-operator ::= 'AND' | 'OR' | 'XOR'
event ::= eventType [whereProposition] [occursMode]
eventType ::= interaction | compPort | mode-change | prop-change
occursMode ::= 'occurs' | 'does-not-occur'
whereProposition ::= 'where' proposition
prop-change ::= logic-expression 'becomes-true'
complex-beh ::= beh beh-operator beh
duringTime ::= 'during' time-interval 
proposition ::= logicExpressHolds | componInMode
logicExpressHolds ::= logic-expression 'holds'
componInMode ::= component 'is-in' mode
logic-expression ::= evalQuantity | compl-eval
compl-eval ::= evaluation comparator evaluation
evalQuantity ::= evaluation 'in' quant-interval
time-interval ::= interval time-unit
time-unit ::= 'ns' | 'ms' | 's'
more-compPorts ::= ',' compPort
interaction ::= 'INTERACTION(' compPort more-compPorts+ ')'
intervalTimes ::= interval 'times'
mode-change ::= 'mode-changes' [forComp] [fromMode] [toMode]
forComp ::= 'for' component
fromMode ::= 'from' mode
toMode ::= 'to' mode
evaluation ::= expression | variable | literal-value | function
more-variables ::= ',' variable
function ::= functionName '(' variable more-variables* ')' functionBody
quant-interval ::= interval [unit]
complex-eval ::= evaluation comparator evaluation
comparator ::= '<' | '>' | '<=' | '>=' | '==' | '!='
localDefinition ::= variableName ':=' evaluation
compPort::= component '.' port
variableHolder ::= component | 'G' | 'L'
variable ::= variableHolder '.' variableName
#interval-part ::= evaluation | '..'
#interval ::= '[' interval-part ',' interval-part ']'
interval ::= interval-left ',' interval-right
interval-left ::= '(..' | inter-left-eval
interval-right ::= '..)' | inter-right-eval
inter-left-eval ::= left-bracket evaluation
inter-right-eval ::= evaluation right-bracket
left-bracket ::= '[' | '('
right-bracket ::= ']' | ')'
expression ::= ''
variableName ::= {PRP:Variable}
literal-value ::= ''
functionName ::= ''
functionBody ::= ''
unit ::= ''
mode ::= { OOoSSA:Mode }
port ::= { OOoSSA:Port }
component ::= { OOoSSA:ComponentType, OOoSSA:ComponentImplementation }
p1 ::= 'Whenever' behPart ',-then' behPart
p2 ::= 'Always' behPart
p3 ::= 'Whenever' behPart enableMode mode 'on' component
enableMode ::= 'enable' | 'disable'
ArchMutex ::= 'Execution between' mutexPart 'is mutually exclusive'
mutexPart ::= component:B 'from' port:B.begin 'to' port:B.finish more-mutexParts+
more-mutexParts ::= 'and' mutexPart
ArchModes ::= component 'has control modes' mode more-modes+ '.' mode-def mode-def+
mode-def::= 'In' mode ',' port 'is enabled.'
more-modes ::= ',' mode
more-ports ::= ',' port